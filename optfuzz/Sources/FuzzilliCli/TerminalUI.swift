// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import Fuzzilli
import NIO
import RediStack

let redis3 = try! RedisConnection.make(
        configuration: try .init(hostname: "127.0.0.1", port: 9067),
        boundEventLoop: MultiThreadedEventLoopGroup(numberOfThreads: 1).next()
    ).wait()

let Seconds = 1.0
let Minutes = 60.0 * Seconds
let Hours   = 60.0 * Minutes
let Days    = 24.0 * Hours

// A very basic terminal UI.
class TerminalUI {
    // If true, the next program generated by the fuzzer will be printed to the screen.
    var printNextGeneratedProgram = false
    // If true, the next interesting program found by this fuzzer will be printed to the screen.
    var printNextInterestingProgram = false

    // Start time of this fuzzing session
    let startTime = Date()

    // Timestamp when the last interesting program was found
    var lastInterestingProgramFound = Date()

    init(for fuzzer: Fuzzer) {
        // Event listeners etc. have to be registered on the fuzzer's queue
        fuzzer.sync {
            self.initOnFuzzerQueue(fuzzer)

        }
    }

    func initOnFuzzerQueue(_ fuzzer: Fuzzer) {
        // Register log event listener now to be able to print log messages
        // generated during fuzzer initialization
        fuzzer.registerEventListener(for: fuzzer.events.Log) { ev in
            let color = self.colorForLevel[ev.level]!
            if ev.origin == fuzzer.id {
                print("\u{001B}[0;\(color.rawValue)m[\(ev.label)] \(ev.message)\u{001B}[0;\(Color.reset.rawValue)m")
            } else {
                // Mark message as coming from a worker by including its id
                let shortId = ev.origin.uuidString.split(separator: "-")[0]
                print("\u{001B}[0;\(color.rawValue)m[\(shortId):\(ev.label)] \(ev.message)\u{001B}[0;\(Color.reset.rawValue)m")
            }
        }

        fuzzer.registerEventListener(for: fuzzer.events.CrashFound) { crash in
            if crash.isUnique {
                print("########## Unique Crash Found ##########")
                print(fuzzer.lifter.lift(crash.program, withOptions: .includeComments))
            }
        }

        fuzzer.registerEventListener(for: fuzzer.events.ProgramGenerated) { program in
            if self.printNextGeneratedProgram {
                print("--------- Randomly Sampled Generated Program -----------")
                print(fuzzer.lifter.lift(program, withOptions: .includeComments))
                self.printNextGeneratedProgram = false
            }
        }

        fuzzer.registerEventListener(for: fuzzer.events.InterestingProgramFound) { program, origin in
            self.lastInterestingProgramFound = Date()
            if self.printNextInterestingProgram {
                print("--------- Randomly Sampled Interesting Program -----------")
                print(fuzzer.lifter.lift(program, withOptions: .includeComments))
                self.printNextInterestingProgram = false
            }
        }

        // Do everything else after fuzzer initialization finished
        fuzzer.registerEventListener(for: fuzzer.events.Initialized) {
            if let stats = Statistics.instance(for: fuzzer) {
                fuzzer.registerEventListener(for: fuzzer.events.Shutdown) { _ in
                    print("\n++++++++++ Fuzzer Finished ++++++++++\n")
                    self.printStats(stats.compute(), of: fuzzer)
                }

                // We could also run our own timer on the main queue instead if we want to
                fuzzer.timers.scheduleTask(every: 60 * Seconds) {
                    self.printStats(stats.compute(), of: fuzzer)
                    print()
                }

                fuzzer.timers.scheduleTask(every: 10 * Minutes) {
                    fuzzer.evaluator.writePath()
                }

                // Randomly sample generated and interesting programs and print them.
                // The goal of this is to give users a better "feeling" for what the fuzzer is currently doing.
                fuzzer.timers.scheduleTask(every: 5 * Minutes) {
                    self.printNextInterestingProgram = true
                    self.printNextGeneratedProgram = true
                }
            }
        }
    }

    func printStats(_ stats: Fuzzilli_Protobuf_Statistics, of fuzzer: Fuzzer) {
        let phase: String
        switch fuzzer.phase {
        case .corpusImport:
            phase = "Corpus import"
        case .initialCorpusGeneration:
            phase = "Initial corpus generation (with \(fuzzer.engine.name))"
        case .fuzzing:
            phase = "Fuzzing (with \(fuzzer.engine.name))"
        }

        let timeSinceLastInterestingProgram = -lastInterestingProgramFound.timeIntervalSinceNow
        let uptime = -startTime.timeIntervalSinceNow
        
        
        let bitmap0 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap0")], mapValueToResult: { $0 })).wait()
        let bitmap1 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap1")], mapValueToResult: { $0 })).wait()
        let bitmap2 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap2")], mapValueToResult: { $0 })).wait()
        let bitmap3 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap3")], mapValueToResult: { $0 })).wait()
        let bitmap4 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap4")], mapValueToResult: { $0 })).wait()
        let bitmap5 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap5")], mapValueToResult: { $0 })).wait()
        let bitmap6 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap6")], mapValueToResult: { $0 })).wait()
        let bitmap7 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap7")], mapValueToResult: { $0 })).wait()
        let bitmap8 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap8")], mapValueToResult: { $0 })).wait()
        let bitmap9 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap9")], mapValueToResult: { $0 })).wait()
        let bitmap10 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap10")], mapValueToResult: { $0 })).wait()
        let bitmap11 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap11")], mapValueToResult: { $0 })).wait()
        let bitmap12 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap12")], mapValueToResult: { $0 })).wait()
        let bitmap13 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap13")], mapValueToResult: { $0 })).wait()
        let bitmap14 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap14")], mapValueToResult: { $0 })).wait()
        let bitmap15 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap15")], mapValueToResult: { $0 })).wait()
        let bitmap16 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap16")], mapValueToResult: { $0 })).wait()
        let bitmap17 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap17")], mapValueToResult: { $0 })).wait()
        let bitmap18 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap18")], mapValueToResult: { $0 })).wait()
        let bitmap19 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap19")], mapValueToResult: { $0 })).wait()
        let bitmap20 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap20")], mapValueToResult: { $0 })).wait()
        let bitmap21 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap21")], mapValueToResult: { $0 })).wait()
        let bitmap22 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap22")], mapValueToResult: { $0 })).wait()
        let bitmap23 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap23")], mapValueToResult: { $0 })).wait()
        let bitmap24 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap24")], mapValueToResult: { $0 })).wait()
        let bitmap25 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap25")], mapValueToResult: { $0 })).wait()
        let bitmap26 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap26")], mapValueToResult: { $0 })).wait()
        let bitmap27 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap27")], mapValueToResult: { $0 })).wait()
        let bitmap28 = try! redis3.send(RedisCommand.init(keyword: "SCARD", arguments: [RESPValue.init(from: "bitmap28")], mapValueToResult: { $0 })).wait()

 
        print("""
        Fuzzer Statistics
        -----------------
        Fuzzer phase:                 \(phase)
        Uptime:                       \(formatTimeInterval(uptime))
        Total Samples:                \(stats.totalSamples)
        Interesting Samples Found:    \(stats.interestingSamples)
        Last Interesting Sample:      \(formatTimeInterval(timeSinceLastInterestingProgram))
        Valid Samples Found:          \(stats.validSamples)
        Corpus Size:                  \(fuzzer.corpus.size)
        My Corpus Size:               \(fuzzer.corpus.size2)
        Correctness Rate:             \(String(format: "%.2f%%", stats.correctnessRate * 100)) (\(String(format: "%.2f%%", stats.globalCorrectnessRate * 100)))
        Timeout Rate:                 \(String(format: "%.2f%%", stats.timeoutRate * 100)) (\(String(format: "%.2f%%", stats.globalTimeoutRate * 100)))
        Crashes Found:                \(stats.crashingSamples)
        Timeouts Hit:                 \(stats.timedOutSamples)
        Coverage:                     \(String(format: "%.2f%%", stats.coverage * 100))
        Avg. program size:            \(String(format: "%.2f", stats.avgProgramSize))
        Avg. corpus program size:     \(String(format: "%.2f", stats.avgCorpusProgramSize))
        Connected workers:            \(stats.numWorkers)
        Execs / Second:               \(String(format: "%.2f", stats.execsPerSecond))
        Fuzzer Overhead:              \(String(format: "%.2f", stats.fuzzerOverhead * 100))%
        Total Execs:                  \(stats.totalExecs)
        LICM::0:                            \(bitmap0)
        ConstantFolding::1:                 \(bitmap1)
        ObjectAllocationSinking::2:         \(bitmap2)
        IntegerRange::3:                    \(bitmap3)
        TypeCheckHoisting::4:               \(bitmap4)
        CFGSimplification::5:               \(bitmap5)
        StrengthReduction::6:               \(bitmap6)
        ArgumentsElimination::7:            \(bitmap7)
        IntegerCheckCombining::8:           \(bitmap8)
        ValueRepReduction::9:               \(bitmap9)
        VarargsForwarding::10:              \(bitmap10)
        BackwardsPropagationPhase::11:      \(bitmap11)
        CSE::12:                            \(bitmap12)
        OSRAvailabilityAnalysis::13:                \(bitmap13)
        PredictionPropagation::14:                  \(bitmap14)
        PutStackSinking::15:                        \(bitmap15)
        SSALowering::16:                            \(bitmap16)
        StoreBarrierInsertion::17:                  \(bitmap17)
        B3CSE::18:                                  \(bitmap18)
        B3FoldPathConstants::19:                    \(bitmap19)
        B3HoistLoopInvariantValues::20:             \(bitmap20)
        B3ReduceDoubleToFloat::21:                  \(bitmap21)
        B3ReduceStrength::22:                       \(bitmap22)
        B3InferSwitches::23:                        \(bitmap23)
        B3LowerMacros::24:                          \(bitmap24)
        B3OptimizeAssociativeExpressionTrees::25:   \(bitmap25)
        B3LowerMacrosAfterOptimizations::26:        \(bitmap26)
        AirSimplifyCFG::27:                         \(bitmap27)
        AirLowerMacros::28:                         \(bitmap28)
        """)
    }


    private func formatTimeInterval(_ interval: TimeInterval) -> String {
        let days = Int(interval / Days)
        let hours = Int(interval / Hours) % 24
        let minutes = Int(interval / Minutes) % 60
        let seconds = Int(interval / Seconds) % 60
        return String(format: "%id %ih %im %is", days, hours, minutes, seconds)
    }

    private enum Color: Int {
        case reset   = 0
        case black   = 30
        case red     = 31
        case green   = 32
        case yellow  = 33
        case blue    = 34
        case magenta = 35
        case cyan    = 36
        case white   = 37
    }

    // The color with which to print log entries.
    private let colorForLevel: [LogLevel: Color] = [
        .verbose: .cyan,
        .info:    .white,
        .warning: .yellow,
        .error:   .red,
        .fatal:   .magenta
    ]
}
